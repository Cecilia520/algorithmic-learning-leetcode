#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""
@File    :   PaintFence.py    
@Contact :   70904372cecilia@gmail.com
@License :   (C)Copyright 2019-2020

@Modify Time      @Author    @Version    @Desciption
------------      -------    --------    -----------
2020/3/24 14:30   cecilia      1.0       栅栏涂色问题
问题描述：
目前有n个栅栏，k种颜色，最多相邻的栅栏的颜色可以相同，那么请问总共有多少种涂色方案呢？
思路分析：动态规划
根据题目意思，可以先使用枚举法来逐步确定转移状态——
i=1，有k种涂色方案；
i=2时，当和i=1相同时，总共k种涂色方案；
    当与i=1不同时，共有k*(k-1)种涂色方案，基于两种情形，总共K+K*（k-1）=K*K种涂色方案；
i=3时，主要看和i=2，如果与i=2相同，那么i=2和i=1一定是不同的，此时共有k*（k-1）种；
    如果与i=2不同，那么i=1和i=2的状态就不影响i=2和i=3的配色（i=1和i=2相同时，i=3的涂色方案是K*(K-1)种；
    i=1和i=2不同时，i=3的涂色方案有K*(K-1)*(K-1)种，总共(K+K*(K-1))*(K-1)种）
题目要求最多两根相邻的栅栏颜色是相同的，此时确定转移状态就是第一根栅栏和第二根栅栏的配色状态，第二根栅栏和第三根栅栏的配色方式，第四根栅栏不受前面三根配色状态影响
由此可知，状态总共有三种：
    第一种：随意配色，可记作0；
    第二种：和前一个栅栏配色相同，有K种；
    第三种：和前一个栅栏配色不同，有K*（K-1）种
简而言之，也可以看作第三根栅栏和第二根栅栏的颜色相同，或者与第一根栅栏颜色相同。
状态可记作：{0，K， K*K, 0}
状态方程：F(i)=F(i-2)*（k-1）+F(i-1)*（k-1）
"""
def paintFence(n, K)->int:
    """
    栅栏涂色
    :param n:栅栏的个数
    :param K: 颜色的种类
    :return:
    时间复杂度O(N),空间复杂度O(1)
    """
    # 初始化转移状态
    dp = [0, K, K*K, 0]

    if n <= 2:
        return dp[n]
    for i in range(3):
        # 状态转移方程
        dp[3] = dp[1]*(K-1) + dp[2]*(K-1)
        dp[1] = dp[2]
        dp[2] = dp[3]
    return dp[3]

if __name__ == '__main__':
    print(paintFence(n=5, K=3))


