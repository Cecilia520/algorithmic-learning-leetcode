#### TopKFrequentElements问题

> 注意：
>
> 1. `topK`问题（前`k`个）使用小顶堆或者桶进行存储，然后对其维护即可。每次压入堆前，和堆顶元素进行比较，如果新元素比堆顶元素还要小，直接扔掉，否则压入堆中。检查堆大小是否超过`k`，如果超过，弹出堆顶。时间复杂度`O(nlogK)`
> 2. 切忌在前`k`个高频问题中使用大顶堆。因为在你把所有元素都压入堆中，最后的复杂度仍然是`O(nlogn)`,并且还浪费内存空间，如果是海量元素的情形下，那这种方式行不通！
> 3. 使用策略：**求前 k 大，用小顶堆，求前 k 小，用大顶堆。**
> 4. `heaq.nlargest(k, iterable, key)`的方法能够直接获得最大`k`长度的数据，相反的`nsmallest`可以获得最小`k`长度的数据，在python的`heaq`包里，比较实用！

#### 荷兰国旗问题

荷兰国旗是由红白蓝3种颜色的条纹拼接而成，假设这样的条纹有多条，且各种颜色的数量不一，并且随机组成了一个新的图形，新的图形可能是红白蓝条纹的情形 需求是：把这些条纹按照颜色排好，红色的在上半部分，白色的在中间部分，蓝色的在下半部分，我们把这类问题称作荷兰国旗问题。

把荷兰国旗问题用数组的形式表达一下是这样的： 给定一个整数数组，给定一个值K，这个值在原数组中一定存在，要求把数组中小于K的元素放到数组的左边，大于K的元素放到数组的右边，等于K的元素放到数组的中间，最终返回一个整数数组，其中只有两个值，分别是等于K的数组部分的左右两个下标值。 例如，给定数组：`[2, 3, 1, 9, 7, 6, 1, 4, 5]`，给定一个值4，那么经过处理原数组可能得一种情况是：`[2, 3, 1, 1, 4, 9, 7, 6, 5]`，需要注意的是，小于4的部分不需要有序，大于4的部分也不需要有序，返回等于4部分的左右两个下标，即`[4, 4]`。

##### 解决思路✍

设计三个指针，`p0`, `p2` 和`curr`来分别追踪`0`的最右边界，`2`的最左边界和当前考虑的元素。 本解法的思路是沿着数组移动 `curr` 指针，若`nums[curr] = 0`，则将其与 `nums[p0]`互换；若 `nums[curr] = 2` ，则与 `nums[p2]`互换。

###### 算法思路📖

- 初始化`0`的最右边界：`p0=0`。在整个算法执行过程中`nums[idx > p0]`。
- 初始化`2`的最左边界 ：`p2 = n - 1`。在整个算法执行过程中 `nums[idx > p2] = 2`。
- 初始化当前考虑的元素序号 ：`curr = 0`.
- While `curr <= p2` :
- - 若 `nums[curr] = 0` ：交换第 `curr`个 和 第`p0`个 元素，并将指针都向右移。
- - 若 `nums[curr] = 2` ：交换第 `curr`个和第 `p2`个元素，并将 `p2`指针左移 。
- - 若 `nums[curr] = 1` ：将指针`curr`右移。

#### 常见排序小结

针对常见排序方式的时间复杂度和空间复杂度如下：

![image](https://github.com/Cecilia520/algorithmic-learning-leetcode/blob/cecilia-python/cecilia-python/sort/sortlist.jpg)
